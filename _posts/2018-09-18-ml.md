---
title: CS-443 Machine Learning
description: "My notes from the CS-443 Machine Learning course given at EPFL, in the 2018 autumn semester (MA1)"
unlisted: true
---

* TOC
{:toc}

‚ö† *Work in progress*

We'll always use subscript $n$ for data point, and $d$ for feature. $N$ is the data size and $D$ is the dimensionality.

Recommended website: <http://www.matrixcalculus.org/>

## Linear regression
A linear regression is a model that assumes a linear relationship between inputs and the output. We will studied three types of methods:

1. Grid search
2. Iterative optimization algorithms
3. Least squares

### Simple linear regression

For a single input dimension ($D=1$), we can use a simple linear regression, which is given by:

$$
y_n \approx f(x_n) := w_0 + w_1 x_{n1}
$$

$w = (w_0, w_1)$ are the parameters of the model.

### Multiple linear regression

If our data has multiple input dimensions, we obtain multivariate linear regression:

$$
y_n \approx 
    f(\pmb{x}_n) :=w_0 + w_1x_{n1}+\dots+w_D x_{wD} 
    = w_0 + \pmb{x}_n^t \begin{bmatrix}
        w_1 \\
        \vdots \\
        w_D \\
    \end{bmatrix}
    = \tilde{\pmb{x}}_n ^T \tilde{\pmb{w}}
$$

> üëâüèº If we wanted to be a little more strict, we should write $f_{\pmb{w}}(\pmb{x}_n)$, as the model of course also depends on the weights.

The tilde notation means that we have included the offset term $w_0$, also known as the **bias**:

$$
\tilde{\pmb{x}}_n=\begin{bmatrix}1 \\ x_{n1} \\ \vdots \\ x_{nD} \end{bmatrix} \in \mathbb{R}^{D+1}, 
\quad
\tilde{\pmb{w}} = \begin{bmatrix}w_0 \\ w_1 \\ \vdots \\ w_D\end{bmatrix} \in \mathbb{R^{D+1}}
$$

### The $D > N$ problem

If the number of parameters exceeds the number of data examples, we say that the task is *under-determined*. This can be solved by regularization, which we‚Äôll get to more precisely later

## Cost functions

$\pmb{x}_n$ is the data, which we can easily understand where comes from. But how does one find a good $\pmb{w}$ from the data? 

A **cost function** (also called loss function) is used to learn parameters that explain the data well. It quantifies how well our model does by giving errors a score, quantifying penalties for errors. Our goal is to find weights that minimize the loss functions.

### Properties

Desirable properties of cost functions are:

- **Symmetry around 0**: that is, being off by a positive or negative amount is equivalent; what matters is the amplitude of the error, not the sign.
- **Robustness**: penalizes large errors at about the same rate as very large errors. This is a way to make sure that outliers don‚Äôt completely dominate our regression.

### Good cost functions

#### MSE

Probably the most commonly used cost function is Mean Square Error (MSE): 

$$
\mathcal{L}_{\text{MSE}}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - f(\pmb{x}_n)\right)^2
\label{def:mse}
$$

MSE is symmetrical aroudn 0, but also tends to penalize outliers quite harshly (because it squares error): MSE is not robust. In practice, this is problematic, because outliers occur more often than we‚Äôd like to.

Note that we often use MSE with a factor $\frac{1}{2N}$ instead of $\frac{1}{N}$. This is because it makes for a cleaner derivative, but we'll get into that later. Just know that for all intents and purposes, it doesn't change really change anything about the behavior of the models we'll study.

#### MAE

When outliers are present, Mean Absolute Error (MAE) tends to fare better:

$$
\text{MAE}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left| y_n - f(\pmb{x}_n)\right|
$$

Instead of squaring, we take the absolute value. This is more robust. Note that MAE isn‚Äôt differentiable at 0, but we‚Äôll talk about that later.

There are other cost functions that are even more robust; these are available as additional reading, but is not exam material.

### Convexity

A function is **convex** iff a line joining two points never intersects with the function anywhere else. More strictly defined, a function $f(\pmb{u})$ with $\pmb{u}\in\chi$ is *convex* if, for any $\pmb{u}, \pmb{v} \in\chi$, and for any $0 \le\lambda\le 1$, we have:

$$
f(\lambda\pmb{u}+(1-\lambda)\pmb{v})\le\lambda f(\pmb{u}) +(1-\lambda)f(\pmb{v})
$$

A function is **strictly convex** if the above inequality is strict ($<$).

A stritly convex function has a unique global minimum $\pmb{w}^*$. For convex functions, every local minimum is a global minimum. This makes it a desirable property for loss functions, since it means that cost function optimization is guaranteed to find the global minimum.

Sums of convex functions are also convex. Therefore, MSE and MAE are convex.

## Optimization

### Learning / Estimation / Fitting

Given a cost function (or loss function) $\mathcal{L}(\pmb{w})$, we wish to find $\pmb{w}^*$ which minimizes the cost:

$$
\min_{\pmb W}{\mathcal{L}(\pmb w)}, \quad\text{ subject to } \pmb w \in \mathbb R^D
$$

This is what we call **learning**: learning is simply an optimization problem, and as such, we‚Äôll use an optimization algorithm to solve it ‚Äì that is, find a good $\pmb w$.

### Grid search

This is one of the simplest optimization algorithms, although far from being the most efficient one. It can be described as ‚Äútry all the values‚Äù, a kind of brute-force algorithm; you can think of it as nested for-loops over the individual $w_i$ weights.

For instance, if our weights are $\pmb{w} = \begin{bmatrix}w_1 \\ w_2\end{bmatrix}$, then we can try, say 4 values for $w_1$, 4 values for $w_2$, for a total of 16 values of $\mathcal{L}(\pmb{w})$.

But obviously, complexity is exponential $\mathcal{O}(a^D)$ (where $a$ is the number of values to try), which is really bad, especially when we can have $D\approx$ millions of parameters. Additionally, grid search has no guarantees that it‚Äôll find an optimum; it‚Äôll just find the best value we tried.

If grid search sounds bad for optimization, that‚Äôs because it is. In practice, it is not used for optimization of parameters, but it *is* used to tune hyperparameters.

### Optimization landscapes

#### Local minimum

A vector $\pmb{w}^\*$ is a *local minimum* of a function $\mathcal{L}$ (we‚Äôre interested in the minimum of cost functions $\mathcal{L}$, which we denote with $\pmb{w}^*$, as opposed to any other value $\pmb{w}$, but this obviously holds for any function) if $\exists \epsilon > 0$ such that

$$
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}

\mathcal{L}(\pmb{w}^*) \le \mathcal{L(\pmb{w})}, \quad \forall\pmb w : \norm{\pmb{w} -\pmb{w}^*} < \epsilon
$$

In other words, the local minimum $\pmb{w}^*$ is better than all the neighbors in some non-zero radius.

#### Global minimum

The global minimum is defined by getting rid of the radius $\epsilon$ and comparing to all other values:

$$
\mathcal{L}(\pmb{w}^*) \le \mathcal{L(\pmb{w})}, \qquad \forall\pmb{w}\in\mathbb{R}^D
$$

#### Strict minimum

A minimum is said to be **strict** if the corresponding equality is strict for $\pmb{w} \ne \pmb{w}^*$, that is, there is only one minimum value.

### Smooth (differentiable) optimization

#### Gradient

A gradient at a given point is the slope of the tangent to the function at that point. It points to the direction of largest increase of the function. By following the gradient (in the opposite direction, because we‚Äôre searching for a minimum and not a maximum), we can find the minimum.

![Graphs of MSE and MAE](/images/ml/mse-mae.png)

Gradient is defined by:

$$
\nabla \mathcal{L}(\pmb{w}) := \begin{bmatrix}
	\frac{\partial\mathcal{L}(\pmb{w})}{\partial w_1} \\
	\vdots \\
	\frac{\partial\mathcal{L}(\pmb{w})}{\partial w_D} \\
\end{bmatrix}
$$

This is a vector, i.e. $\nabla\mathcal{L}(\pmb{w})\in\mathbb R^D$. Each dimension $i$ of the vector indicates how fast the cost $\mathcal{L}$ changes depending on the weight $w_i$.

#### Gradient descent

Gradient descent is an iterative algorithm. We start from a candidate $w^{(t)}$, and iterate.

$$
\pmb{w}^{(t+1)}:=\pmb{w}^{(t)} - \gamma \nabla\mathcal{L}\left(\pmb{w}^{(t)}\right)
$$

As stated previously, we‚Äôre adding the negative gradient to find the minimum, hence the substraction.

$\gamma$ is known as the **step-size**, which is a small value (maybe 0.1). You don‚Äôt want to be too aggressive with it, or you might risk overshooting in your descent. In practice, the step-size that makes the learning as fast as possible is often found by trial and error ü§∑üèº‚Äç‚ôÇÔ∏è.

As an example, we will take an analytical look at a gradient descent, in order to understand its behavior and components. We will do gradient descent on a 1-parameter model, in which we minimize the MSE, which is defined as follows:

$$
\mathcal{L}\left(w_0\right)=\frac{1}{2N}\sum_{n=1}^N{\left(y_n - w_0\right)^2}
$$

Note that we‚Äôre dividing by 2 on top of the regular MSE; it has no impact on finding the minimum, but when we will compute the gradient below, it will conveniently cancel out the $\frac{1}{2}$.

The gradient of $\mathcal{L}\left(w_0\right)$ is:

$$
\begin{align}
\nabla\mathcal{L}\left(\pmb{w}\right)
	& = \frac{\partial}{\partial w_0}\mathcal{L} \\
	& = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
	& = w_0 - \bar{y}
\end{align}
$$

And thus, our gradient descent is given by:

$$
\begin{align*}
w_0^{(t+1)}
	&:= w_0^{(t)} - \gamma\nabla\mathcal{L}\left(\pmb w\right) \\
	& = w_0^{(t)} - \gamma(w_0^{(t)} - \bar{y}) \\
	& = (1-\gamma)w_0^{(t)} + \gamma\bar{y}, 
	\qquad\text{where } \bar{y}:=\sum_{n}{\frac{y_n}{N}}
\end{align*}
$$

This sequence is guaranteed to converge for $\pmb{w}^* = \bar{y}$ (so the solution to this exact problem can be extracted analytically from gradient descent). This would set the cost function to 0, which is the minimum.

The choice of $\gamma$ has an influence on the algorithm‚Äôs outcome:

- If we pick $\gamma=1$, we would get to the optimum in one step
- If we pick $\gamma < 1$, we would get a little closer in every step, eventually converging to $\bar{y}$
- If we pick $\gamma > 1$, we are going to overshoot $\bar{y}$. Slightly bigger than 1 (say, 1.5) would still converge; $\gamma=2$ would loop infinitely between two points; $\gamma > 2$ diverges.

#### Gradient descent for linear MSE

Our linear regression is given by a line $\pmb{y}$ that is a regression for some data $\pmb X$:

$$
\pmb{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\pmb{X}=\begin{bmatrix}
x_{11} & x_{12} & \dots & x_{1D} \\
x_{21} & x_{22} & \dots & x_{2D} \\
\vdots & \vdots & \ddots & \vdots \\
x_{N1} & x_{N2} & \dots & x_{ND} \\
\end{bmatrix}
$$

Our model is:

$$
f_w(x)=\pmb{x}_n^T \pmb{w}
$$

We define the error vector by:

$$
\pmb{e}=\pmb{y} - \pmb{Xw}, 
\quad \text{ or } \quad 
\pmb{e}_n = \pmb{x}_n^T\pmb{w}
$$

The MSE can then be restated as follows:

$$
\mathcal{L}\left(\pmb{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \pmb{x}_n^T \pmb{w}\right)^2}
	=  \frac{1}{2N}\pmb{e}^T\pmb{e}
$$

And the gradient is, component-wise:

$$
\frac{\partial}{\partial\pmb{w}_d}\mathcal{L}
	= -\frac{1}{2N}\sum_{n=1}^N {2(y_n - \pmb{x}_n^T \pmb{w}) \pmb{x}_{nd}}
	= -\frac{1}{N} (\pmb{X}_{:d})^T \pmb{e}
$$

We‚Äôre using column notation $\pmb{X}_{:d}$ to signify column $d$ of the matrix $X$.

And thus, all in all, our gradient is:

$$
\nabla\mathcal{L}\left(\pmb{w}\right) = -\frac{1}{N}\pmb{X}^T\pmb{e}
$$

To compute this expression, we must compute:

- The error $\pmb e$, which takes $2N\cdot D - 1$ floating point operations (flops) for the matrix-vector multiplication, and $N$ for the subtraction, for a total of $2N\cdot D + N - 1$, which is $\mathcal{O}(N\cdot D)$
- The gradient $\nabla\mathcal{L}$, which costs $2N\cdot D + D - 1$, which is $\mathcal{O}(N\cdot D)$.

In total, this process is $\mathcal{O}(N\cdot D)$ at every step. This is not too bad, it‚Äôs equivalent to reading the data once.

#### Stochastic gradient descent (SGD)

In ML, most cost functions are formulated as a sum of:

$$
\mathcal{L}\left(\pmb{w}\right) = \frac{1}{N}\sum_{n=1}^N{\mathcal{L}_n(\pmb{w})}
$$

In practice, this can be expensive to compute, so the solution is to pick a random $n$ uniformly at random in $n\in\left[1, N\right]$ to be able to make the sum go away.

The stochastic gradient descent is thus:

$$
\pmb{w}^{(t+1)}:=\pmb{w}^{(t)} - \gamma \nabla\mathcal{L}_n\left({\pmb{w}^{(t)}}\right)
$$

Why is it allowed to pick just one $n$ instead of the full thing? We won‚Äôt give a full proof, but the intuition is that:

$$
\mathbb{E}\left[ \nabla\mathcal{L}_n(\pmb{w}) \right] 
	= \frac{1}{N} \sum_{n=1}^N{\nabla\mathcal{L}_n(\pmb{w})}
	= \nabla\left(\frac{1}{N} \sum_{n=1}^N{\mathcal{L}_n(\pmb{w})}\right)
	\equiv \nabla\mathcal{L}\left(\pmb{w}\right)
$$

The gradient of a single n is:

$$
\mathcal{L}_n(\pmb{w}) = \frac{1}{2} \left(y_n -\pmb{x}_n^T w\right)^2 \\
\nabla\mathcal{L}_n(\pmb{w}) = (-x_n^T) (y_n-\pmb{x}_n^T \pmb{w})
$$

Note that $x_n^T \in\mathbb{R}^D$, and $(y_n-\pmb{x}_n^T \pmb{w})\in\mathbb{R}$. Computational complexity for this is $\mathcal{O}(D)$. 

#### Mini-batch SGD

But perhaps just picking a **single** value is too extreme; there is an intermediate version in which we choose a subset $B\subseteq \left[N\right]$ instead of $\|B\|$ points, instead of a single point.

$$
g := \frac{1}{|B|}\sum_{n\in B}{\nabla\mathcal{L}_n(\pmb{w}^{(t)})} \\
w^{(t+1)} := w^{(t)} - \gamma\pmb{g}
$$

Note that if $\|B\| = N$ then we‚Äôre performing a full gradient descent.

The computation of $\pmb{g}$ can be parallelized easily over $\|B\|$ GPU threads, which is quite common in practice; $\|B\|$ is thus often dictated by the number of available threads.

Computational complexity is $\mathcal{O}(\|B\|\cdot D)$.

### Non-smooth (non-differentiable) optimization

We‚Äôve defined convexity previously, but we can also use the following alternative characterization of convexity:

$$
\mathcal{L}\left(\pmb u\right) \ge \mathcal{L}\left(\pmb w\right) + \nabla \mathcal{L}\left(\pmb w\right)^T(\pmb{u} - \pmb{w}) \quad \forall \pmb{u}, \pmb{w}
\iff \mathcal{L} \text{ convex}
$$

Meaning that the function must always lie above its linearization (which is the first-order Taylor expansion) to be convex.

![A convex function lies above its linearization](/images/ml/convex-above-linearization.png)

#### Subgradients

A vector $\pmb{g}\in\mathbb{R}^D$ such that:

$$
\mathcal{L}\left(\pmb u\right) \ge \mathcal{L}\left(\pmb w\right) + \pmb{g}^T(\pmb u - \pmb w) \quad \forall \pmb{u}, \pmb{w}
$$

is called a **subgradient** to the function $\mathcal{L}$ at $\pmb w$. The subgradient forms a line that is always below the curve, somewhat like the gradient of a convex function.

![The subgradient lies below the function](/images/ml/subgradient-below-function.png)

This definition is valid even for an arbitrary $\mathcal{L}$ that may not be differentiable, and not even necessarily convex.

If the function $\mathcal{L}$ is differentiable at $\pmb w$, then the *only subgradient* at $\pmb{w}$ is $\pmb{g} = \nabla\mathcal{L}\left(\pmb{w}\right)$.

#### Subgradient descent

This is exactly like gradient descent, except for the fact that we use the *subgradient* $\pmb{g}$ at the current iterate $\pmb{w}^{(t)}$ instead of the *gradient*:

$$
w^{(t+1)} := w^{(t)} - \gamma\pmb{g}
$$

For instance, MAE is not differentiable at 0, so we must use the subgradient.

$$
\text{Let }h: \mathbb{R} \rightarrow \mathbb{R}, \quad h(e) := |e| \\
\text{At } e, \text{the subgradient }
g \in \partial h = \begin{cases}
-1 & \text{if } e < 0 \\
[-1, 1] & \text{if } e = 0 \\
1 & \text{if } e > 0 \\
\end{cases}
$$

Here, $\partial h$ is somewhat confusing notation for the set of all possible subgradients at our position.

For linear regressions, the (sub)gradient is easy to compute using the *chain rule*.

Let $h$ be non-differentiable, $q$ differentiable, and $\mathcal{L}\left(\pmb{w}\right) = h(q(w))$. The chain rule tells us that, at $\pmb w$, our subgradient is:

$$
g \in \partial h(q(\pmb{w})) \cdot \nabla q(\pmb{w})
$$

#### Stochastic subgradient descent

This is still commonly abbreviated SGD.

It‚Äôs exactly the same, except that $\pmb g$ is a subgradient to the randomly selected $\mathcal{L}_n$ at the current iterate $\pmb{w}^{(t)}$.



### Comparison

|                             | Smooth                                                       | Non-smooth                                                   |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Full gradient descent       | Gradient of $$\mathcal{L}$$ <br />Complexity is $\mathcal{O}(N\cdot D)$ | Subgradient of $\mathcal{L}$<br />Complexity is $\mathcal{O}(N\cdot D)$ |
| Stochastic gradient descent | Gradient of $\mathcal{L}_n$                                | Subgradient of $\mathcal{L}_n$                             |



### Constrained optimization

Sometimes, optimization problems come posed with an additional constraint.

#### Convex sets

We‚Äôve seen convexity for functions, but we can also define it for sets. A set $\mathcal{C}$ is convex iff the line segment between any two points of $\mathcal{C}$ lies in $\mathcal{C}$. That is, $\forall \pmb{u}, \pmb{v} \in \mathcal{C}, \quad \forall 0 \le \theta \le 1$, we have:

$$
\theta \pmb{u} + (1 - \theta)\pmb{v} \in \mathcal{C}
$$

This means that the line between any two points in the set $\mathcal{C}$ must also be fully contained within the set.

![Examples of convex and non-convex sets](/images/ml/convex-sets.png)

A couple of properties of convex sets:

- Intersection of convex sets is also convex.
- Projections onto convex sets are **unique** (and often efficient to compute).


#### Projected gradient descent

When dealing with constrained problems, we have two options. The first one is to add a projection onto $\mathcal{C}$ in every step:

$$
P_\mathcal{C}(\pmb{w}') := \arg{\min_{\pmb{v}\in\mathcal{C}}}\norm{\pmb{v-w'}}
$$

The rule for gradient descent can thus be updated to become:

$$
w^{(t+1)} := P_\mathcal{C}\left(w^{(t)} - \gamma \nabla \mathcal{L}(w^{(t)}) \right)
$$

This means that at every step, we compute the new $w^{(t+1)}$ normally, but apply a projection on top of that. In other words, if the regular gradient descent sets our weights outside of the constrained space, we project them back.

<figure>
    <img alt="Steps of projected SGD" src="/images/ml/projected-sgd.png" />
    <figcaption>Here, $w'$ is the result of regular SGD, i.e. $w' = w^{(t)} - \gamma \nabla \mathcal{L}(w^{(t)})$</figcaption>
</figure>

This is the same for stochastic gradient descent, and we have the same convergence properties.

Note that the computational cost of the projection is very important here, since it is performed at every step.

#### Turning constrained problems into unconstrained problems

If projection as described above is approach A, this is approach B.

We use a **penalty function**, such as the ‚Äúbrick wall‚Äù indicator function below:

$$
I_\mathcal{C}(\pmb w) = \begin{cases}
0 & \pmb{w} \in \mathcal{C} \\
+\infty & \pmb{w} \notin \mathcal{C}
\end{cases}
$$

We could also perhaps use something with a less drastic error value than $+\infty$, if we don‚Äôt care about the constraint quite as extreme.

Note that this is similar to regularization, which we‚Äôll talk about later. 

Now, instead of directly solving $min_{\pmb{w}\in\mathcal{C}}{\mathcal{L}(\pmb{w})}$, we solve for:

$$
\min_{\pmb{w}\in \mathbb{R}^D} {
    \mathcal{L}(\pmb{w}) + I_\mathcal{C}(\pmb{w})
}
$$

### Implementation issues in gradient methods

#### Stopping criteria

When $\norm{\mathcal{L}(\pmb{w})}$ is zero (or close to zero), we are often close to the optimum.

#### Optimality

If the second order derivative is positive (or positive semi-definite for the general case $D\ge1$), then it is a (possibly local) minimum. If the function is also convex, then this is necessarily a global minimum. That is:

$$
\nabla \mathcal{L(\pmb{w})} = 0, \quad \mathcal{L} \text{ convex}
\implies
\text{optimum at }\pmb{w}
$$

#### Step size

If $\gamma$ is too big, we might diverge ([as seen previously](#gradient-descent)). But if it is too small, we might be very slow! Convergence is only guaranteed for $\gamma < \gamma_{min}$, which is a value that depends on the problem. 

## Least squares

### Normal equations

In some rare cases, we can take an analytical approach to computing the optimum of the cost function, rather than a computational one; for instance, for linear regressen with MSE, as we've done previously. These types of equations are sometimes called **normal equations**. This is one of the most popular methods for data fitting, called **least squares**.

How do we get these normal equations?

First, we show that the problem is convex. If that is the case, then according to the [optimality conditions](#optimality) for convex functions, the point at which the derivative is zero is the optimum:

$$
\mathcal{L}(\pmb{w}^*)=\pmb{0}
$$

This gives us a system of $D$ equations known as the normal equations.

### Single parameter linear regression
Let's try this for a single parameter linear regression, with MSE as the cost function. 

First, we will just accept that the cost function is convex in the $w_0$ parameter. 

As [proven previously](#gradient-descent), we know that for the single parameter model, the derivative is:

$$
\begin{align}
\nabla\mathcal{L}\left(\pmb{w}\right)
    & = \frac{\partial}{\partial w_0}\mathcal{L} \\
    & = \frac{1}{2N}\sum_{n=1}^N{-2(y_n - w_0)}  \\
    & = w_0 - \bar{y}
\end{align}
$$

This means that the derivative is 0 for $w_0 = \bar{y}$. This allows us to define our optimum parameter $\pmb{w}^\*$ as $\pmb{w}^* = \begin{bmatrix}\bar{y}\end{bmatrix}$.

### Multiple parameter linear regression

As we know by now, the cost function for linear regression with MSE is:

$$
\mathcal{L}\left(\pmb{w}\right)
	:= \frac{1}{2N}\sum_{n=1}^N{\left( y_n - \pmb{x}_n^T \pmb{w}\right)^2}
	=  \frac{1}{2N}(\pmb{y-Xw})^T(\pmb{y-Xw})
$$


Where the matrices are defined as:

$$
\pmb{y}=\begin{bmatrix}
	y_1 \\ y_2 \\ \vdots \\ y_N
\end{bmatrix}, 
\quad
\pmb{X}=\begin{bmatrix}
x_{11} & x_{12} & \dots & x_{1D} \\
x_{21} & x_{22} & \dots & x_{2D} \\
\vdots & \vdots & \ddots & \vdots \\
x_{N1} & x_{N2} & \dots & x_{ND} \\
\end{bmatrix}
$$


We denote the $i^\text{th}$ row of $X$ by $x_i^T$. Each $x_i^T$ represents a different data point.

We claim that this cost function is *convex* in $\pmb{w}$. We can prove that in any of the following ways:

***

#### Simplest way
The cost function is the sum of many convex functions, and is thus also convex.

#### Directly verify the definition

$$
\forall \lambda\in [0,1], 
\quad \forall \pmb{w}, \pmb{w}',
\qquad
\mathcal{L}\left(\lambda\pmb{w} + \left(1-\lambda\right)\pmb{w}'\right) 
- \left(\lambda\mathcal{L}(\pmb{w}) + \left( 1-\lambda \right) \mathcal{L}(\pmb{w}')\right) \le 0
$$
  
The left-hand side of the inequality reduces to:
  
$$
-\frac{1}{2N}\lambda(1-\lambda)\norm{\pmb{X}(\pmb{w}-\pmb{w}')}_2^2
$$
   
which is indeed non-positive.

#### Compute the Hessian

The Hessian is the matrix of second derivatives, defined as follows:

$$
H_{ij} = \left( \frac{\partial\mathcal{L}}{\partial w_i \partial w_j} \right)_{ij}
$$

If the Hessian is positive semidefinite (i.e. all its eigenvalues are non-negative), then the function is convex.
  
For our case, the Hessian is given by:
  
$$
\frac{1}{N}\pmb{X}^T\pmb{X}
$$
  
This is indeed positive semi-definite, as its eigenvalues are the squares of the eigenvalues of $\pmb{X}$, and must therefore be positive.

***

Knowing that the function is convex, we can find the minimum. If we take the gradient of this expression, we get:

$$
\nabla\mathcal{L}(\pmb{w}) = -\frac{1}{N}\pmb{X}^T(\pmb{y-Xw})
$$

We can set this to 0 to get the normal equations for linear regression, which are:

$$
\pmb{X}^T(\pmb{y-Xw}) =: \pmb{X}^T\pmb{e} = \pmb{0}
$$

This proves that the normal equations for linear regression are given by $\pmb{X}^T\pmb{e} = \pmb{0}$.

### Geometric interpretation

The above definition of normal equations are given by $\pmb{X}^T\pmb{e} = \pmb{0}$. How can visualize that?

The error is given by:

$$
\pmb{e} := \pmb{y} - \pmb{Xw}
$$

By definition, this error vector is orthogonal to all columns of $\pmb{X}$. Indeed, it tells us how far above or below the span our prediction $\pmb{y}$ is. 

The **span** of $\pmb{X}$ is the space spanned by the columns of $\pmb{X}$. Every element of the span can be written as $\pmb{u} = \pmb{Xw}$ for some choice of $\pmb{w}$. 

For the normal equations, we must pick an optimal $\pmb{w}^\*$ for which the gradient is 0. Picking an $\pmb{w}^\*$ is equivalent to picking an optimal $\pmb{u}^* = \pmb{Xw}^\*$ from the span of $\pmb{X}$.

But which element of $\text{span}(\pmb{X})$ shall we take, which one is the optimal one? The normal equations tell us that the optimum choice for $\pmb{u}$, called $$\pmb{u}^*$$ is the element such that $$\pmb{y} - \pmb{u}^*$$ is orthogonal to $\text{span}(X)$.

In other words, we should pick $\pmb{u}^*$ to be the projection of $\pmb{y}$ onto $\text{span}(\pmb{X})$.

![Geometric interpretation of the normal equations](/images/ml/geometric-interpretation-normal-equations.png)


### Least squares
All we've done so far is to solve the same old problem of a matrix equation:

$$
Ax = b
$$

But we've always done so with a bit of a twist; there may not be an exact value of $x$ satisfying exact equality, but we could find one that gets us as close as possible:

$$
Ax \approx b
$$

This is also what least squares does. It attempts to minimize the MSE to get as $Ax$ close as possible to $b$.

In this course, we often denote the data matrix $A$ as $\pmb{X}$, the weights $x$ as $\pmb{w}$, and $b$ as $y$; in other words, we're trying to solve:

$$
\pmb{X}\pmb{w} \approx \pmb{y}
$$

In least squares, we multiply this whole equation by $\pmb{X}^T$ on the left. We attempt to find $\pmb{w}^*$, the minimal weight that gets us as minimally wrong as possible. In other we're trying to solve:

$$
\left( \pmb{X}^T\pmb{X} \right) \pmb{w} \approx \pmb{X}^T\pmb{y}
$$

One way to solve this problem would simply be to invert the $A$ matrix, which in our case is $\pmb{X}^T\pmb{X}$:

$$
\pmb{w}^* = (\pmb{X}^T\pmb{X})^{-1} \pmb{X}^T y
$$

As such, we can use this model to predict values for unseen datapoints:

$$
\hat{y}_m := \pmb{x}_m^T \pmb{w}^* = \pmb{x}_m^T (\pmb{X}^T\pmb{X})^{-1} \pmb{X}^T y
$$

### Invertibility and uniqueness
Note that the Gram matrix, defined as $\pmb{X}^T\pmb{X} \in \mathbb{R}^{D\times D}$, is invertible **if and only if** $\pmb{X}$ has **full column rank**, or in other words, $\text{rank}(\pmb{X}) = D$.

$$
\pmb{X}^T\pmb{X} \in \mathbb{R}^{D\times D} \text{ invertible}
\iff
\text{rank}(\pmb{X}) = D
$$

Unfortunately, in practice, our data matrix $\pmb{X}\in\mathbb{R}^{N\times D}$ is often **rank-deficient**.

- If $D>N$, we always have $\text{rank}(\pmb{X}) < D$ (since column and row rank are the same).
- If $D \le N$, but some of the columns $\pmb{x}_{:d}$ are collinear (or in practice, nearly collinear), then the matrix is **ill-conditioned**. This leads to numerical issues when solving the linear system.
  
  To know how bad things are, we can compute the condition number, which is the maximum eigenvalue of the Gram matrix, divided by the minimum See course contents of Numerical Methods.

If our data matrix is rank-deficient or ill-conditioned (which is practically always the case), we certainly shouldn't be inverting it directly! We'll introduce high numerical errors that falsify our output.

That doesn't mean we can't do least squares in practice. We can still use a linear solver. In Python, that means you should use [`np.linalg.solve`](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.solve.html), which uses a LU decomposition internally and thus avoids the worst numerical errors. In any case, do not directly invert the matrix as we have done above! 


## Maximum likelihood
Maximum likelihood offers a second interpretation of least squares, but starting with a probabilistic approach.

### Gaussian distribution
A Gaussian random variable in $\mathbb{R}$ has mean $\mu$ and variance $\sigma^2$. 

$$
\mathcal{N}(y \mid \mu, \sigma^2) = 
    \frac{1}{\sqrt{2\pi\sigma^2}} 
    \exp{\left[ -\frac{(y-\mu)^2}{2\sigma^2} \right]}
$$

For a Gaussian random *vector* (instead of a single random variable), with mean $\pmb{\mu}$ and covariance $\pmb{\Sigma}$ (which is positive semi-definite) is:

$$
\pmb{\mathcal{N}}(\pmb{y} \mid \pmb{\mu}, \pmb{\Sigma}) = 
    \frac{1}
         {\sqrt{(2\pi)^D \text{ det}(\pmb{\Sigma})}} 

    \exp{\left[ -\frac{1}{2} (\pmb{y} - \pmb{\mu})^T \pmb{\Sigma}^{-1} (\pmb{y} - \pmb{u}) \right]}
$$

Remember that $\pmb{y} \in \mathbb{R}^N$. 

As another reminder, two variables $x$ and $y$ are said to be **independent** when $p(x, y) = p(x)p(y)$.

### A probabilistic model for least squares
We assume that our data is generated by a linear model $\pmb{x}_n^T\pmb{w}$, with added Gaussian noise $\epsilon_n$:

$$
y_n = \pmb{x}_n^T\pmb{w} + \epsilon_n
$$

This is often a realistic assumption in practice.

![Noise generated by a Gaussian source](/images/ml/gaussian-noise.png)

The noise is $\epsilon_n \sim^{iid.} \mathcal{N}(y_n \mid \mu = 0, \sigma^2)$ for each dimension $n$. In other words, it is centered at 0, has a certain variance, and the error in each dimension is independent of that in other dimensions. The model $\pmb{w}$ is, as always, unknown.

Given $N$ samples, the **likelihood** of the data vector $\pmb{y} = (y_1, \dots, y_n)$ given the model $\pmb{w}$ and the input $\pmb{X}$ (where each row is one input) is:

$$
p(\pmb{y} \mid \pmb{X}, \pmb{w}) 
    = \prod_{n=1}^N {p(y_n \mid \pmb{x}_n, \pmb{w})}
    = \prod_{n=1}^N {\mathcal{N}(y_n \mid \pmb{x}_n^T\pmb{w}, \sigma^2)}
$$

Intuitively, we'd like to maximize this likelihood over the choice of the best model $\pmb{w}$. The best model is the one that maximizes this likelihood.

### Defining cost with log-likelihood
The log-likelihood (LL) is given by:

$$
\mathcal{L}_{LL} := \log{p(\pmb{y} \mid \pmb{X}, \pmb{w})}
    = - \frac{1}{2\sigma^2} \sum_{n=1}^N{\left(y_n - \pmb{x}_n^T\pmb{w}\right)^2} + \text{ cnst}
$$

Taking the log allows us to get away from the nasty product, and get a nice sum instead.

Notice that this definition looks pretty similar to MSE:

$$
\mathcal{L}_{\text{MSE}}(\pmb{w}) := \frac{1}{N} \sum_{n=1}^N \left(y_n - f(\pmb{x}_n)\right)^2
$$

Note that we would like to minimize MSE, but we want LL to be as high as possible (intuitively, we can look at the sign to understand that).

### Maximum likelihood estimator (MLE)
Maximizing the log-likelihood (and thus the likelihood) will be equivalent to minimizing the MSE; this gives us another way to design cost functions. We can describe the whole process as:

$$
\arg{\min_{\pmb{w}}{\mathcal{L}_\text{MSE}(\pmb{w})}}
=
\arg{\max_{\pmb{w}}{\mathcal{L}_\text{LL}(\pmb{w})}}
$$

The maximum likelihood estimator (MLE) can be understood as finding the model under which the observed data is most likely to have been generated from (probabilistically). This interpretation has some advantages that we discuss below. 

#### Properties of MLE
MLE is a *sample* approximation to the *expected log-likelihood*. In other words, if we had an infinite amount of data, MLE would perfectly be equal to the expected value of the log-likelihood.

$$
\mathcal{L}_{LL}(\pmb{w}) 
    \approx \mathbb{E}_{p(y, \pmb{x})} \left[ \log{p(x \mid \pmb{x}, \pmb{w})} \right]
$$

This means that MLE is **consistent**, i.e. it gives us the correct model assuming we have enough data. In probability, we can write this as:

$$
\pmb{w}_\text{MLE} \longrightarrow^p \pmb{w}_\text{true}
$$

This sounds amazing, but the catch is that this all is under the assumption that the noise $\epsilon$ indeed was generated under a Gaussian model.

## Overfitting and underfitting

### Underfitting with linear models
Linear models can very easily underfit; as soon as the data itself is given by anything more complex than a line, fitting a linear model will underfit: the model is too simple for the data, and we'll have huge errors.

But we can also easily overfit, where our model learns the specificities of the data too intimately. And this happens quite easily with linear combination of high-degree polynomials.

### Extended feature vectors
We can actually get high-degree linear combinations of polynomials, but still keep our linear model. Instead of making the model more complex, we simply "augment" the input to become degree $M$. If the input is one-dimensional, we can add a polynomial basis to the input:

$$
\pmb{\phi}(x_n) =
\begin{bmatrix}
1 & x_n & x_n^2 & x_n^3 & \dots & x_n^M
\end{bmatrix}
$$

Note that this is basically a [Vandermonde matrix](https://en.wikipedia.org/wiki/Vandermonde_matrix).

We then fit a linear model to this extended feature vector $\pmb{\phi}(x_n)$:

$$
y_n \approx w_0 + w_1 x_n + w_2 x_n^2 + \dots + w_m x_n^M =: \pmb{\phi}(x_n)^T\pmb{w}
$$

Here, $\pmb{w}\in\mathbb{R}^{M+1}$. In other words, there are $M+1$ parameters in a degree $M$ extended feature vector. One should be careful with this degree; too high may overfit, too low may underfit.

If it is important to distinguish the original input $\pmb{x}$ from the augmented input $\pmb{phi}(\pmb{x})$ then we will use the $\pmb{phi}(\pmb{x})$ notation. But often, we can just consider this as a part of the pre-processing, and simply write $\pmb{x}$ as the input, which will save us a lot of notation.

### Reducing overfitting
To reduce overfitting, we can chose a less complex model (in the above, we can pick a lower degree $M$), but we could also just add more data:

![An overfitted model acts more reasonably when we add a bunch of data](/images/ml/reduce-overfit-add-data.png)

## Regularization
To prevent overfitting, we can introduce **regularization** to penalize complex models. This can be applied to any model.

The idea is to not only minimize cost, but also minimize a regularizer:

$$
\min_{\pmb{w}} {\mathcal{L}(\pmb{w}) + \Omega(\pmb{w})}
$$

The $\Omega$ function is the regularizer, measuring the complexity of the model. We'll see some good candidates for the regularizer below.

### $L_2$-Regularization: Ridge Regression
The most frequently used regularizer is the standard Euclidian norm ($L_2$-norm):

$$
\Omega(\pmb{w}) = \lambda \norm{\pmb{w}}^2_2
$$

Where $\lambda \in \mathbb{R}$. The value of $\lambda$ will affect the fit; $\lambda \rightarrow 0$ can have overfitting, while $\lambda \rightarrow \infty$ can have underfitting.

The norm is given by:

$$
\norm{\pmb{w}}_2^2 = \sum_i{w_i^2}
$$

The main effect of this is that large model weights $w_i$ will be penalized, while small ones won't affect our minimization too much.

#### Ridge regression
Depending on the values we choose for $\mathcal{L}$ and $\Omega$, we get into some special cases. For instance, choosing MSE for $\mathcal{L}$ is called **ridge regression**, in which we optimize the following:

$$
\min_{\pmb{w}} {\left(\frac{1}{N} \sum_{n=1}^N \left[y_n - f(\pmb{x}_n)\right]^2 \quad + \quad \Omega(\pmb{w})\right)}
$$

Least squares is also a special case of ridge regression, where $\lambda = 0$

We can find an explicit solution for $\pmb{w}$ in ridge regression by differentiating the cost and regularizer, and setting them to zero:

$$
\begin{align}
\nabla \mathcal{L}(\pmb{w}) & = -\frac{1}{N} \pmb{X}^T (\pmb{y} - \pmb{Xw}) \\ \\
\nabla \Omega(\pmb{w}) & = 2\lambda \pmb{w} \\
\end{align}
$$

We can now set the full cost to zero, which gives us the result:

$$
\pmb{w}^*_\text{ridge} = (\pmb{X}^T\pmb{X} + \lambda' \pmb{I})^{-1}\pmb{X}^T\pmb{y}
$$

Where $\frac{\lambda'}{2N} = \lambda$. Note that for $\lambda = 0$, we indeed have the solution least squares. 

#### Ridge regression to fight ill-conditioning 
This formulation of $\pmb{w}^*$ is quite nice, because adding the identity matrix helps us get something that always is invertible; in cases where we have ill-conditioned matrices, it also means that we can invert with more stability.

We'll prove that the matrix indeed is invertible. The gist is that the eigenvalues of $(\pmb{X}^T\pmb{X} + \lambda' \pmb{I})$ are all at least $\lambda'$. 

To prove it, we'll write the singular value decomposition (SVD) of $\pmb{X}^T\pmb{X}$ as $\pmb{USU}^T$. We then have:

$$
\pmb{X}^T\pmb{X} + \lambda'\pmb{I} = \pmb{USU}^T + \lambda'\pmb{UIU}^T = \pmb{U}(\pmb{S} + \lambda'\pmb{I})\pmb{U}^T
$$

The singular value is "lifted" by an amount $\lambda'$. There's an alternative proof in the class notes, but we won't go into that.

### $L_1$ Regularization: The Lasso
We can use a different norm as an alternative measure of complexity. The combination of $L_1$-norm and MSE is known as **The Lasso**:

$$
\min_{\pmb{w}} {\frac{1}{2N} \sum_{n=1}^N \left[y_n - f(\pmb{x}_n)\right]^2 \quad + \quad \lambda \norm{w}_1^1}
$$

Where the $L_1$-norm is defined as

$$
\norm{w}_1^1 := \sum_i{\|w_i\|}
$$

If we draw out a constant value of the $L_1$ norm, we get a sort of "ball". Below, we've graphed $\left\\{ \pmb{w} \mid \norm{\pmb{w}}_1 \le 5 \right\\}$.

![Graph of the lasso](/images/ml/lasso.png)

To keep things in the following, we'll just claim that $\pmb{X}^T\pmb{X}$ is invertible. We'll also claim that the following set is an ellipsoid which scales around the origin as we change $\alpha$:

$$
\left\{
    \pmb{w} \mid \norm{\pmb{y} - \pmb{Xw}}^2 = \alpha
\right\}
$$

The slides have a formal proof for this, but we won't get into it.

Note that the above definition of the set corresponds to the set of points with equal loss (which we can assume is MSE, for instance):

$$
\left\{
    \pmb{w} \mid \mathcal{L}(\pmb{w}) = \alpha
\right\}
$$

Under these assumptions, we claim that for $L_1$ regularization, the optimum solution will likely be sparse (many zero components) compared to $L_2$ regularization.

To prove this, suppose we know the $L_1$ norm of the optimum solution. Visualizing that ball, we know that our optimum solution $\pmb{w}^\*$ will be somewhere on the surface of that ball. We also know that there are ellipsoids, all with the same mean and rotation, describing the equal error surfaces. The optimum solution is where the "smallest" of these ellipsoids just touches the
$L_1$ ball.

![Intersection of the L1 ball and the cost ellipses](/images/ml/ball-ellipse.png)

Due to the geometry of this ball this point is more likely to be on one of the "corner" points. In turn, sparsity is desirable, since it leads to a "simple" model.

